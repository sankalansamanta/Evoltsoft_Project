import { defineStore } from 'pinia';
import axios from 'axios';
import { ref } from 'vue';
import { API_URL } from '../config';

// Define the Station interface to match backend data structure
export interface Station {
  _id: string; // MongoDB ID
  name: string;
  location: {
    latitude: number;
    longitude: number;
    address?: string | null; // Address can be optional and might be null from backend
  };
  status: 'active' | 'inactive' | 'maintenance'; // Specific allowed status values
  powerOutput: number; // Power output in kW
  connectorType: string; // Type of connector
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
  // Assuming 'createdBy' might also be present if it's stored in the backend
  createdBy?: string;
}

// Define the StationInput interface for data sent to the backend (e.g., for create/update)
// This should exclude fields generated by the backend like _id, createdAt, updatedAt
export interface StationInput {
  name: string;
  location: {
    latitude: number;
    longitude: number;
    address?: string | null; // Address can be optional and might be null when sending
  };
  status: 'active' | 'inactive' | 'maintenance';
  powerOutput: number;
  connectorType: string;
}

export const useStationsStore = defineStore('stations', () => {
  const stations = ref<Station[]>([]); // Reactive array to store all stations
  const currentStation = ref<Station | null>(null); // Reactive object for a single station
  const loading = ref(false); // Loading state for async operations
  const error = ref<string | null>(null); // Error message state

  /**
   * Fetches all charging stations from the backend.
   * @returns {Promise<Station[]>} An array of stations or an empty array on failure.
   */
  const fetchStations = async (): Promise<Station[]> => {
    loading.value = true;
    error.value = null;

    try {
      const response = await axios.get(`${API_URL}/stations`);
      stations.value = response.data; // Assign fetched data to stations state
      return response.data;
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to fetch stations';
      console.error('Error fetching stations:', err);
      return [];
    } finally {
      loading.value = false;
    }
  };

  /**
   * Fetches a single charging station by its ID.
   * @param {string} id - The ID of the station to fetch.
   * @returns {Promise<Station | null>} The fetched station object or null on failure/not found.
   */
  const fetchStationById = async (id: string): Promise<Station | null> => {
    loading.value = true;
    error.value = null;

    try {
      const response = await axios.get(`${API_URL}/stations/${id}`);
      currentStation.value = response.data; // Assign fetched data to currentStation state
      return response.data;
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to fetch station';
      console.error(`Error fetching station ${id}:`, err);
      return null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Creates a new charging station.
   * @param {StationInput} stationData - The data for the new station.
   * @returns {Promise<Station | null>} The created station object or null on failure.
   */
  const createStation = async (stationData: StationInput): Promise<Station | null> => {
    loading.value = true;
    error.value = null;

    try {
      const response = await axios.post(`${API_URL}/stations`, stationData);
      // After creation, refetch all stations to update the list
      await fetchStations();
      return response.data;
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to create station';
      console.error('Error creating station:', err);
      return null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Updates an existing charging station.
   * @param {string} id - The ID of the station to update.
   * @param {StationInput} stationData - The updated data for the station.
   * @returns {Promise<Station | null>} The updated station object or null on failure.
   */
  const updateStation = async (id: string, stationData: StationInput): Promise<Station | null> => {
    loading.value = true;
    error.value = null;

    try {
      const response = await axios.put(`${API_URL}/stations/${id}`, stationData);
      // After update, refetch all stations to ensure list is current
      await fetchStations();
      return response.data;
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to update station';
      console.error(`Error updating station ${id}:`, err);
      return null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Deletes a charging station by its ID.
   * @param {string} id - The ID of the station to delete.
   * @returns {Promise<boolean>} True if deletion was successful, false otherwise.
   */
  const deleteStation = async (id: string): Promise<boolean> => {
    loading.value = true;
    error.value = null;

    try {
      await axios.delete(`${API_URL}/stations/${id}`);
      // Remove the deleted station from the local state
      stations.value = stations.value.filter(station => station._id !== id);
      return true;
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to delete station';
      console.error(`Error deleting station ${id}:`, err);
      return false;
    } finally {
      loading.value = false;
    }
  };

  // Expose state and actions from the store
  return {
    stations,
    currentStation,
    loading,
    error,
    fetchStations,
    fetchStationById,
    createStation,
    updateStation,
    deleteStation
  };
});
